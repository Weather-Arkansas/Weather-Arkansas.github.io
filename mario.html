<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mario with custom ground and animation</title>
<style>
  body {
    margin: 0;
    background: #5c94fc;
    overflow: hidden;
  }
  canvas {
    display: block;
    margin: auto;
    background: #8ED0F7;
  }
</style>
</head>
<body>
<canvas id="game" width="640" height="360"></canvas>

<script>
// Canvas setup
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const GRAVITY = 0.5;
const JUMP_SPEED = -10;
const MOVE_SPEED = 3;

const groundY = 300; // vertical position of the ground (lower on screen)

// Keyboard input
const keys = {};
window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// Mario sprite frames from videgamesprites.net SMB1 character sheet
const marioSprite = new Image();
marioSprite.src = "https://www.videogamesprites.net/SuperMarioBros1/Characters/Mario/spritesheet.png";

// Frame data: each frame's x,y,width,height on the sprite sheet
// These correspond to standing and walking small Mario frames (16x16 px)
const frames = {
  standRight: { x: 0, y: 0, w: 16, h: 16 },
  walkRight1: { x: 16, y: 0, w: 16, h: 16 },
  walkRight2: { x: 32, y: 0, w: 16, h: 16 },
  standLeft: { x: 0, y: 16, w: 16, h: 16 },
  walkLeft1: { x: 16, y: 16, w: 16, h: 16 },
  walkLeft2: { x: 32, y: 16, w: 16, h: 16 }
};

// Player object
const player = {
  x: 50,
  y: groundY - 32,  // 32 is scaled height of mario (16*2)
  width: 32,
  height: 32,
  vx: 0,
  vy: 0,
  onGround: true,
  facing: "right", // or "left"
  frameIndex: 0,
  frameTimer: 0
};

// Animation sequence arrays for walking
const walkRightFrames = [frames.walkRight1, frames.walkRight2];
const walkLeftFrames = [frames.walkLeft1, frames.walkLeft2];

// Draw ground as a simple green rectangle
function drawGround() {
  ctx.fillStyle = "#0B6A0B"; // dark green
  ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
}

// Check collision with ground
function checkGroundCollision(y) {
  return y + player.height >= groundY;
}

// Update player position and physics
function updatePlayer() {
  // Horizontal movement
  if (keys["arrowright"] || keys["d"]) {
    player.vx = MOVE_SPEED;
    player.facing = "right";
  } else if (keys["arrowleft"] || keys["a"]) {
    player.vx = -MOVE_SPEED;
    player.facing = "left";
  } else {
    player.vx = 0;
  }

  // Jumping
  if ((keys["arrowup"] || keys["w"] || keys[" "]) && player.onGround) {
    player.vy = JUMP_SPEED;
    player.onGround = false;
  }

  // Apply gravity
  player.vy += GRAVITY;

  // Apply velocities
  player.x += player.vx;
  player.y += player.vy;

  // Ground collision
  if (checkGroundCollision(player.y)) {
    player.y = groundY - player.height;
    player.vy = 0;
    player.onGround = true;
  } else {
    player.onGround = false;
  }

  // Keep player inside canvas horizontally
  if (player.x < 0) player.x = 0;
  if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

  // Animation frame control
  if (player.vx !== 0 && player.onGround) {
    player.frameTimer++;
    if (player.frameTimer > 10) {
      player.frameIndex = (player.frameIndex + 1) % 2;
      player.frameTimer = 0;
    }
  } else {
    player.frameIndex = 0; // idle frame
    player.frameTimer = 0;
  }
}

// Draw Mario based on facing and animation frame
function drawPlayer() {
  let frame;
  if (player.facing === "right") {
    frame = player.vx === 0 ? frames.standRight : walkRightFrames[player.frameIndex];
  } else {
    frame = player.vx === 0 ? frames.standLeft : walkLeftFrames[player.frameIndex];
  }

  ctx.imageSmoothingEnabled = false; // preserve pixel art sharpness
  ctx.drawImage(
    marioSprite,
    frame.x, frame.y, frame.w, frame.h,
    player.x, player.y, player.width, player.height
  );
}

// Main game loop
function gameLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  drawGround();
  updatePlayer();
  drawPlayer();

  requestAnimationFrame(gameLoop);
}

// Wait for Mario sprite to load before starting
marioSprite.onload = () => {
  gameLoop();
};
</script>
</body>
</html>
